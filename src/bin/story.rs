pub mod story { # ! [ allow ( dead_code , unused_imports , unreachable_code , non_snake_case ) ] use inkgen :: { yield_all , runtime } ; pub const ID : runtime :: StoryID = runtime :: StoryID ( "a1972e14-efe1-4db3-9ed4-18765ffc5eb3" ) ; pub fn story ( ) -> runtime :: Story { let input = runtime :: Input :: default ( ) ; let state = runtime :: WrappedState :: default ( ) ; runtime :: Story :: new ( ID , input . clone ( ) , state . clone ( ) , move || { loop { let choices = { let state = state . lock ( ) . unwrap ( ) ; let mut choices = vec ! [ ] ; if false || ! state . visited ( runtime :: StoryPoint :: Unnamed ( "030787e9-acd7-4af6-a2d9-4476c723576e" ) ) { choices . push ( vec ! [ runtime :: Part :: Text ( "Sure" ) ] ) ; } if false || ! state . visited ( runtime :: StoryPoint :: Unnamed ( "463ab10e-ec6c-47a7-a68e-322d82aeb04f" ) ) { choices . push ( vec ! [ runtime :: Part :: Text ( "Nope" ) ] ) ; } choices } ; yield runtime :: Paragraph :: new ( vec ! [ runtime :: Part :: Text ( "Hello. I think you\'re due for a story about now. Care to begin?" ) ] , Some ( choices ) , ) ; let choice = * input . lock ( ) . unwrap ( ) ; let mut i = 0 ; if false || ! state . lock ( ) . unwrap ( ) . visited ( runtime :: StoryPoint :: Unnamed ( "030787e9-acd7-4af6-a2d9-4476c723576e" ) ) { i += 1 ; } if i == choice { state . lock ( ) . unwrap ( ) . visit ( runtime :: StoryPoint :: Unnamed ( "030787e9-acd7-4af6-a2d9-4476c723576e" ) ) ; yield runtime :: Paragraph :: new ( vec ! [ runtime :: Part :: Text ( "Excellent. Let\'s get started then." ) ] , None ) ; let continuation = runtime :: Paragraph :: new ( vec ! [ ] , None ) ; let mut gen : Box < dyn runtime :: Generator < Yield = runtime :: Paragraph , Return = ( ) > + Sync + Send > = Box :: new ( knot_Story :: entry ( input , state ) ) ; match unsafe { runtime :: Generator :: resume ( & mut gen ) } { runtime :: GeneratorState :: Yielded ( paragraph ) => { yield continuation . join ( paragraph ) ; yield_all ! { gen } } runtime :: GeneratorState :: Complete ( ( ) ) => yield continuation , } break ; } if false || ! state . lock ( ) . unwrap ( ) . visited ( runtime :: StoryPoint :: Unnamed ( "463ab10e-ec6c-47a7-a68e-322d82aeb04f" ) ) { i += 1 ; } if i == choice { state . lock ( ) . unwrap ( ) . visit ( runtime :: StoryPoint :: Unnamed ( "463ab10e-ec6c-47a7-a68e-322d82aeb04f" ) ) ; yield runtime :: Paragraph :: new ( vec ! [ runtime :: Part :: Text ( "Oh, well um. I guess I\'ll be seeing you around then." ) , runtime :: Part :: Tag ( "Lose" ) ] , None ) ; return ; break ; } } } ) } mod knot_Story { use inkgen :: { yield_all , runtime } ; pub ( super ) fn entry ( input : runtime :: Input , state : runtime :: WrappedState ) -> impl runtime :: Generator < Yield = runtime :: Paragraph , Return = ( ) > + Sync + Send { move || { yield runtime :: Paragraph :: new ( vec ! [ runtime :: Part :: Text ( "Once upon a time, there were two children\u{2014}Alice and Bob, I\'ll call them." ) ] , None ) ; let continuation = runtime :: Paragraph :: new ( vec ! [ runtime :: Part :: Text ( "Now, you must know, Alice and Bob weren\'t exactly normal children..." ) , runtime :: Part :: Glue ] , None ) ; let mut gen : Box < dyn runtime :: Generator < Yield = runtime :: Paragraph , Return = ( ) > + Sync + Send > = Box :: new ( stitch_char_intro ( input , state ) ) ; match unsafe { runtime :: Generator :: resume ( & mut gen ) } { runtime :: GeneratorState :: Yielded ( paragraph ) => { yield continuation . join ( paragraph ) ; yield_all ! { gen } } runtime :: GeneratorState :: Complete ( ( ) ) => yield continuation , } } } pub ( super ) fn stitch_char_intro ( input : runtime :: Input , state : runtime :: WrappedState ) -> impl runtime :: Generator < Yield = runtime :: Paragraph , Return = ( ) > + Sync + Send { move || { loop { let choices = { let state = state . lock ( ) . unwrap ( ) ; let mut choices = vec ! [ ] ; if false || ! state . visited ( runtime :: StoryPoint :: Named ( "alice" ) ) { choices . push ( vec ! [ runtime :: Part :: Text ( "" ) , runtime :: Part :: Text ( "Tell me about Alice" ) ] ) ; } if false || ! state . visited ( runtime :: StoryPoint :: Named ( "bob" ) ) { choices . push ( vec ! [ runtime :: Part :: Text ( "" ) , runtime :: Part :: Text ( "Tell me about Bob" ) ] ) ; } if true || ! state . visited ( runtime :: StoryPoint :: Unnamed ( "c29e80d8-2d8c-4c70-b07f-dcbf6fe8d1eb" ) ) { choices . push ( vec ! [ runtime :: Part :: Text ( "That\'s all I need to know" ) ] ) ; } choices } ; yield runtime :: Paragraph :: new ( vec ! [ runtime :: Part :: Text ( "Care to hear more?" ) ] , Some ( choices ) , ) ; let choice = * input . lock ( ) . unwrap ( ) ; let mut i = 0 ; if false || ! state . lock ( ) . unwrap ( ) . visited ( runtime :: StoryPoint :: Named ( "alice" ) ) { i += 1 ; } if i == choice { state . lock ( ) . unwrap ( ) . visit ( runtime :: StoryPoint :: Named ( "alice" ) ) ; yield runtime :: Paragraph :: new ( vec ! [ runtime :: Part :: Text ( "" ) ] , None ) ; yield runtime :: Paragraph :: new ( vec ! [ runtime :: Part :: Text ( "Well you see, Alice was well versed in the dark arts\u{2014}forbidden magics and the like. A master at" ) ] , None ) ; yield runtime :: Paragraph :: new ( vec ! [ runtime :: Part :: Glue , runtime :: Part :: Text ( "potions like none other. Needless to say, a dangerous character. She didn\'t keep many friends," ) ] , None ) ; yield runtime :: Paragraph :: new ( vec ! [ runtime :: Part :: Glue , runtime :: Part :: Text ( "or rather, many friends didn\'t keep her. Those who didn\'t recognize her for who she truly was," ) ] , None ) ; yield runtime :: Paragraph :: new ( vec ! [ runtime :: Part :: Glue , runtime :: Part :: Text ( "well... I can\'t say it turned out well for them. Other than Bob that is." ) ] , None ) ; let continuation = runtime :: Paragraph :: new ( vec ! [ ] , None ) ; let mut gen : Box < dyn runtime :: Generator < Yield = runtime :: Paragraph , Return = ( ) > + Sync + Send > = Box :: new ( stitch_char_intro ( input , state ) ) ; match unsafe { runtime :: Generator :: resume ( & mut gen ) } { runtime :: GeneratorState :: Yielded ( paragraph ) => { yield continuation . join ( paragraph ) ; yield_all ! { gen } } runtime :: GeneratorState :: Complete ( ( ) ) => yield continuation , } break ; } if false || ! state . lock ( ) . unwrap ( ) . visited ( runtime :: StoryPoint :: Named ( "bob" ) ) { i += 1 ; } if i == choice { state . lock ( ) . unwrap ( ) . visit ( runtime :: StoryPoint :: Named ( "bob" ) ) ; yield runtime :: Paragraph :: new ( vec ! [ runtime :: Part :: Text ( "" ) ] , None ) ; yield runtime :: Paragraph :: new ( vec ! [ runtime :: Part :: Text ( "Bob was a man of intelligence above all others. I have never seen anyone else who had a grasp of" ) ] , None ) ; yield runtime :: Paragraph :: new ( vec ! [ runtime :: Part :: Glue , runtime :: Part :: Text ( "such a variety of subjects as Bob. The only thing he seemed unable to master was magic. The" ) ] , None ) ; yield runtime :: Paragraph :: new ( vec ! [ runtime :: Part :: Glue , runtime :: Part :: Text ( "fundamentally non-sensical nature of magic didn\'t sit well in his entirely too rational mind." ) ] , None ) ; yield runtime :: Paragraph :: new ( vec ! [ runtime :: Part :: Glue , runtime :: Part :: Text ( "Maybe Alice\'s skills were what inspired Bob to stick around with her all this time." ) ] , None ) ; let continuation = runtime :: Paragraph :: new ( vec ! [ ] , None ) ; let mut gen : Box < dyn runtime :: Generator < Yield = runtime :: Paragraph , Return = ( ) > + Sync + Send > = Box :: new ( stitch_char_intro ( input , state ) ) ; match unsafe { runtime :: Generator :: resume ( & mut gen ) } { runtime :: GeneratorState :: Yielded ( paragraph ) => { yield continuation . join ( paragraph ) ; yield_all ! { gen } } runtime :: GeneratorState :: Complete ( ( ) ) => yield continuation , } break ; } if true || ! state . lock ( ) . unwrap ( ) . visited ( runtime :: StoryPoint :: Unnamed ( "c29e80d8-2d8c-4c70-b07f-dcbf6fe8d1eb" ) ) { i += 1 ; } if i == choice { state . lock ( ) . unwrap ( ) . visit ( runtime :: StoryPoint :: Unnamed ( "c29e80d8-2d8c-4c70-b07f-dcbf6fe8d1eb" ) ) ; yield runtime :: Paragraph :: new ( vec ! [ runtime :: Part :: Text ( "Well, lucky for you, that\'s all I have to tell." ) ] , None ) ; yield runtime :: Paragraph :: new ( vec ! [ runtime :: Part :: Text ( "See you around, friend." ) , runtime :: Part :: Tag ( "Win" ) ] , None ) ; return ; break ; } } } } } }
